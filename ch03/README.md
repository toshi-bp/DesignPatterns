# `Template Method`パターン

# 概要
- `Template Method`パターンとはテンプレートの機能を持つパターンである
- スーパークラスの方にテンプレートとなるメソッドが定義されている
- メソッドの定義の中では抽象メソッドが使われている
    - →スーパークラスのプログラムを読むだけでは, 最終的にどんな処理をすることになるかはわからない
    - 抽象メソッドをどのように呼び出しているかはわかる
- 抽象メソッドはサブクラスで実際に実装される
    - サブクラスの側で実装をすることで具体的な処理を決定する
    - もちろん, 異なるサブクラスで異なる実装を行えば, 異なる処理が行われる
- 処理の大きな流れはスーパークラスで組み立てた通りになる

# サンプルプログラム
サンプルプログラムは「文字や文字列を5回繰り返して表示する」というものである.

サンプルプログラムのクラス一覧
| クラス名 | 解説 |
| --- | --- |
| `AbstractDisplay` | メソッド`display`のみ実装している**抽象クラス** |
| `CharDisplay` | メソッド`open`, `print`, `close`を実装しているクラス |
| `StringDisplay` | メソッド`open`, `print`, `close`を実装しているクラス |
| Main | 動作テスト用のクラス |

## 備考
- `AbstractDisplay`クラスは`open`, `print`, `close`, `display`というメソッドを持っている
    - この内, `open`, `print`, `close`は抽象メソッドで, `display`メソッドのみ実装されている
    - なお, `display`メソッドでは以下の処理が行われている
        - `open`メソッドを呼び出す
        - `print`メソッドを5回呼び出す
        - `close`メソッドを呼び出す
    - `open`, `print`, `close`メソッドが実際の行う処理はサブクラスにて実装されることになる(→`AbstractDisplay`クラスを見ただけではわからない)
- `CharDisplay`クラスではスーパークラスである`AbstractDisplay`クラスで抽象メソッドとなっていた`open`, `print`, `close`メソッドが実装されている→抽象クラスではない
    - `CharDisplay`クラスの各メソッドの処理は以下に示す通りである
        | メソッド名 | 処理 |
        | --- | --- |
        | `open` | 文字列`<<`を表示する |
        | `print` | コンストラクタで与えられていた1文字を表示する |
        | `close` | 文字列`>>`を表示する |
- `StringDisplay`クラスでも`CharDisplay`クラスと同様に`open`, `print`, `close`メソッドが実装されている
    - `StringDisplay`クラスの各メソッドの処理は以下に示す通りである
        | メソッド名 | 処理 |
        | --- | --- |
        | `open` | 文字列`+----+`を表示する |
        | `print` | コンストラクタで与えられていた文字列を`||`で挟んで表示する |
        | `close` | 文字列`+----+`を表示する |
- `Main`クラスでは`CharDisplay`クラスと`StringDisplay`クラスのインスタンスを作り, `display`メソッドを呼び出している

# 登場人物
- `AbstractClass`(抽象クラス)
    - テンプレートメソッドを実装する
    - テンプレートメソッドで使っている抽象メソッドを**宣言する**
    - 抽象メソッドはサブクラスである`ConcreteClass`役によって実装される
    - サンプルプログラムでは, `AbstractDisplay`クラスがこれに該当する
- `ConcreteClass`(具象クラス)
    - `AbstractClass`役で定義されている抽象メソッドを具体的に実装する
    - ここで実装したメソッドは, `AbstractClass`役のテンプレートメソッドから呼び出される
    - サンプルプログラムでは, `CharDisplay`クラスや`StringDisplay`クラスがこれに該当する

# Template Methodパターンを使う意義
- `Template Method`パターンを使うと, スーパークラスのテンプレートメソッドでアルゴリズムが記述されているため, サブクラス側でアルゴリズムをいちいち記述する必要がなくなる
- `Template Method`パターンでは, スーパークラスとサブクラスが綿密に連絡をとって動いているため, スーパークラスで宣言されている抽象メソッドを実際にサブクラスで実装する際には, そのメソッドがどのタイミングで呼び出されるかを理解しておく必要がある
- スーパークラス型の変数に, サブクラスのインスタンスのどれを代入しても正しく動作する, という原則`The Liskov Substitution Principle(LSP)`と呼ばれており, 継承の一般的な原則である

# 関連しているパターン
- Factory Methodパターン(第4章)
- Strategyパターン(第10章)

# 補足
## スーパークラスからサブクラスへの要請
サブクラスの視点で考えた際には
- スーパークラスで定義されているメソッドがサブクラスで利用できる
- サブクラスに少しメソッドを書くだけで新しい機能が追加できる
- サブクラスでメソッドをオーバーライドすれば振る舞いを変更できる

という点によく目が向けられる.
しかし, スーパークラスの視点で考えると(スーパークラスで抽象メソッドが宣言されているとする)
- メソッドの実装自体はサブクラスに任されている
- サブクラスがそのメソッドを実装することを期待する
- サブクラスに対して, そのメソッドの実装を要請する

→サブクラスには, スーパークラスで宣言されている抽象メソッドを実装するという責任が生じている(`subclass responsibility`(サブクラスの責任))

## 抽象クラスの意義
抽象クラスでは, メソッドの名前を決めて, そのメソッドを使ったテンプレートメソッドによって処理を記述する

→抽象クラスの段階で**処理の流れを形作る**

## スーパークラスとサブクラスの協調
スーパークラスとサブクラスは, お互いに協調し合いながらプログラムを構築している.
### スーパークラスとサブクラスの関係
- スーパークラスの記述量が多い→サブクラスの記述が楽になるが, サブクラスの自由度は減る
- スーパークラスの記述量が少ない→サブクラスの記述は大変になり, 個々のサブクラスで処理の記述が重複してしまう可能性が出てくる
### `Template Method`パターンでは
- 処理の骨組み→スーパークラスで記述
- 具体的な処理→サブクラスで記述

# 練習問題の回答
## 3-1
`java.io.InputStream`では`Template Method`パターンが用いられており, そのサブクラスで実装することが要請されているメソッドは`read`メソッドである.
以下ドキュメントからの引用
>
>```java
>public abstract int read()
>    throws IOException
>```
>入力ストリームからデータの次のバイトを読み込みます。バイト値は、0 - 255の範囲のintとして返されます。ストリームの終わりに達したために読み込むバイトがない場合は、-1が返されます。入力データが読み込めるようになるか、ストリームの終わりが検出されるか、または例外が発生するまで、このメソッドはブロックされます。
サブクラスは、このメソッドの実装を提供しなければなりません。

>戻り値:
データの次のバイト。ストリームの終わりに達した場合は-1。
例外:
IOException - 入出力エラーが発生した場合。

## 3-2
サンプルプログラムの`AbstractDisplay`クラスの`display`メソッドが
```java
public final void display() {
    ...
}
```
と実装されている. ここに`final`をつけることでこのメソッドはオーバーライドできないことを表している.

## 3-3
サンプルプログラムで, `open`, `print`, `close`メソッドを継承関係及び同一パッケージにあるクラスのみから呼び出せるようにし, 無関係な他のクラスからは呼び出せないようにするためには, `protected`宣言をすれば良い.
以下具体例(`StringDisplay`クラスより)
```java
protected void print() {
    System.out.println("|" + string + "|");
}
```

## 3-4
Javaのインターフェースと抽象クラスはよく似ている(インターフェースも抽象メソッドの集まりである)が, `Template Method`パターンで`AbstractClass`役にインターフェースを使うことができないのは, 処理の骨組み(抽象メソッドを用いた処理の流れを示す別のメソッド)も設定しなければならないからである.(インターフェースは抽象メソッドしか設定できない)

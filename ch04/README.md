# `Factory Method`パターン
# 概要
- `Factory Method`パターンとは, 第3章で触れた`Template Method`パターンをインスタンス生成の場面に適用したパターンである.
- `Factory Method`パターンでは, インスタンスの作り方をスーパークラスの側で定めるのだが, 具体的なクラス名については定めず, 全てサブクラスの側で行う.
    - これにより, インスタンス生成のための枠組み(フレームワーク)と, 実際のインスタンス生成のクラスとを分けて考えることができるようになる.

# サンプルプログラム
サンプルプログラムは身分証明書カード(IDカード)を作る工場を題材としたものである.
このプログラムには5つのクラスが登場する.
それぞれのクラスのの概要については以下に示す通りである.

クラス一覧
| パッケージ名 | クラス名 | 解説 |
| --- | --- | --- |
| framework | Product | 抽象メソッド`use`のみ定義されている抽象クラス |
| framework | Factory | メソッド`create`を実装している抽象クラス |
| idcard | IDCard | メソッド`use`を実装しているクラス |
| idcard | IDCardFactory | メソッド`createProduct`, `registerProduct`を実装しているクラス |
| なし | Main | 動作テスト用のクラス |

## 備考
- `framework`パッケージは`Product`クラスと`Factory`クラスを包含しており, この2つのクラスはインスタンス生成のための枠組み(フレームワーク)の役割を果たす
- `idcard`パッケージの`IDCard`クラスと`IDCardFactory`クラスで実際の肉付けを行う
- 公開するパッケージを開発する場合, ドメイン名を逆にした文字列を使って, 世界に1つだけのパッケージ名にすることが推奨されている(例:`hyuki.com→com.hyuki`など, Java言語関連)
- `framework`パッケージの`Product`クラスは「製品」を表現したクラスであり, 抽象メソッドの`use`のみが宣言されている
    - `use`メソッドの具体的な実装はサブクラスの方で行う
    - このフレームワークでは, 製品とは「何はともあれ, useできる(使える)もの」と規定していることになる
    - javaではabstractなコンストラクタを作ることができない(以下のようなコードを書くとエラーとなってしまう)
        ```java
        public abstract Product(String name);
        ```
        - コンストラクタは継承されないため, abstractなコンストラクタに意味はない
        - 名前を引数として与えることを強制するためには, 専用のメソッドを作成する必要がある
- `framework`パッケージの`Factory`クラスでは, `Template Method`パターンが使われている
    - 抽象メソッド`createProduct`で「製品を作り」, 作った製品を抽象メソッド`registerProduct`で「登録」している
    - 「製品を作る」と「登録」の実装はサブクラスで行われる
    - このフレームワークでは, 工場とは「`create`メソッドで`Product`のインスタンスを生成するもの」と規定している
    - `create`メソッドは「`createProduct`で製品を作って, `registerProduct`で登録する」という手順として実装されている
    - `Factory Method`パターンの時, インスタンス生成に`Template Method`パターンが使われることになる
- `IDCard`クラスでは, 認識番号カードを表している
    - フレームワークから分離していることを明示するため, `idcard`パッケージという別のパッケージにプログラムを作成している
    - `IDCard`クラスは`Product`クラスのサブクラスとして定義する
    - `idcard`以外のパッケージで`new`を用いたインスタンス生成をできないようにするため, コンストラクタには`public`と設定していない
- `IDCardFactory`クラスでは, `concreteProduct`と`registerProduct`の2つのメソッドを実装している
    - `createProduct`では, `IDCard`のインスタンスを生成することで, 「製品を作る」ことを実際に実現している
    - `registerProduct`では, `IDCard`の`owner`(所有者)を`owners`フィールドに追加して, 「登録」という機能を実現している

# 登場人物
- `Product`(製品)
    - フレームワーク側であり, `Factory Method`パターンで生成されるインスタンスが持つべきインターフェース(API)を定める抽象クラス
    - 具体的な内容は`ConcreteProduct`役が定める
    - サンプルプログラムでは, `Product`クラスがこの役を務めている
- `Creator`(作成者)
    - フレームワーク側であり, `Product`役を生成する抽象クラスである
    - 具体的な内容はサブクラスの`ConcreteCreator`役が定める
    - サンプルプログラムでは, `Factory`クラスがこの役を務めている
    - `Creator`役は, 実際に生成する`ConcreteProduct`役については何も知らない
        - 知っているのは, `Product`役とインスタンス生成のメソッドを呼び出せば, `Product`が生成されるということだけである
        - サンプルプログラムでは, `createProduct`メソッドがインスタンス生成のためのメソッドになっている
        - **`new`による実際のインタスタンス生成を, インスタンス生成のためのメソッド呼び出しに代えることで, 具体的なクラス名による束縛からスーパークラスをを解放していることになる**
- `ConcreteProduct`(具体的製品)
    - 具体的な肉付けをする側であり, 具体的な製品を定める
    - サンプルプログラムでは, `IDCard`クラスがこの役を務めている
- `ConcreteCreator`(具体的作成者)
    - 具体的な肉付けをする側であり, 具体的な製品を作るクラスを定める
    - サンプルプログラムでは, `IDCardFactory`クラスがこの役を務めている

# パターンを使う意義
## フレームワークと肉付け
このパターンでは, 「フレームワーク」と「肉付け」の2つの側について押さえていった(サンプルプログラムにおける`framework`パッケージと`idcard`パッケージ). もし, 新たな「製品」と「工場」を作ることになった場合, `framework`パッケージを一切修正せずに, 新たな(全く別の)製品を作ることができる.
## インスタンス生成(メソッドの実装方法)
サンプルプログラムにおける`Factory`クラスの`createProduct`メソッドは抽象メソッドになっている. このメソッドはサブクラスで実装することが期待されているクラスである. `createProduct`メソッドの記述方法には以下の3通りが考えられる.
1. 抽象メソッドにする
    - 抽象メソッドにすると, サブクラスは必ずこのメソッドを実装しなければならなくなる(実装しないとコンパイルの際に検出される).
    ```java
    abstract class Factory {
        public abstract Product createProduct(String name);
        ...
    }
    ```
1. デフォルトの実装を用意しておく
    - デフォルトの実装を用意しておくと, サブクラスで実装しなかった場合に, こちらの実装が用いられる.
    - ただし, この場合には`Product`クラスに対して直接`new`しているため, `Product`クラスを抽象クラスにしておくことはできない.
    ```java
    class Factory {
        public Product createProduct(String name) {
            return new Product(name);
        }
        ...
    }
    ```
1. エラーにする
    - デフォルトの実装の内容をエラーにしておくと サブクラスで実装しなかった場合には, 実行時にエラーが吐き出される(エラーになって, 実装されていないことを教えてくれる).
    - ただし, エラーを起こす用の関数(下のサンプルにおける`FactoryMethodRuntimeException`)は別途作成する必要がある.
    ```java
    class Factory {
        public Product createProduct(String name) {
            throw new FactoryMethodRuntimeException();
        }
    }
    ```
## パターン利用と開発者側の意思疎通
`Template Method`パターン(第3章)と`Factory Method`パターン(本章)では, 以下の3つのことが必要となる.
1. スーパークラスで動作の骨組みを理解すること
1. そこで使われている抽象メソッドが何かを見極めること
1. その抽象メソッドを実際に実装しているクラスのソースコードを読むこと

また, 一般に, デザインパターンを使って, あるクラス群を設計する場合, そのクラス群の保守を行う人に, 設計者の意図したデザインパターンが何であるかうまく伝わるようにする必要がある.

設計者の最初の意図から離れた修正が加えられてしまわないように, プログラムのコメントや開発文書の中に, 実際に使われているデザインパターンの名称と意図を記述しておくのは有用である.

# 関連しているパターン
- Template Methodパターン(第3章)
- Singletonパターン(第5章)
- Compositeパターン(第11章)
- Iteratorパターン(第1章)
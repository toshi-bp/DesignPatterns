# `Adapter`パターン

# 概要
- `Adapter`パターンとは「既に提供されているもの」と「必要なもの」の間の「ずれ」を埋めるようなデザインパターンのことである.
- adapterとは, 必要なものとの間に入って, その間を埋める役割を果たす.
    > adapt: 適合させる
- プログラムの場合, 既に提供されているものがそのまま使えない時に, 必要な形に変換してから利用することがよくある.
- `Adapter`パターンは`Wrapper`パターンと呼ばれることもある
    > wrapper: 包むもの
- `Adapter`パターンには以下の2種類がある
    1. クラスによる`Adapter`パターン(継承を使ったもの)
    1. インスタンスによる`Adapter`パターン(委譲を使ったもの)

# サンプルプログラム
## クラスによる`Adapter`パターン(継承を使ったもの)
サンプルプログラムは, 与えられた文字列を
```
({与えられた文字列})
```
のように表示したり,
```
*{与えられた文字列}*
```
のように表示したりするものである.

サンプルプログラムにおける電源の比喩とそれぞれのプログラムの対応関係は以下に示す通りである.

電源の比喩とサンプルプログラムの対応関係
|| 電源の比喩 | サンプルプログラム | 備考 |
| --- | --- | --- | --- |
| 提供されているもの | 交流100V | `Banner`クラス ||
| 変換装置 | アダプター | `PrintBanner`クラス |  |
| 必要なもの | 直流12V | `Print`インターフェース ||

### 備考
- `PrintBanner`クラスでは,
    - 用意されている`Banner`クラスを拡張(`extends`)して, `showWithParen`メソッドと`showWithAster`メソッドを継承している
    - 要求されている`Print`インターフェースを実装`implements`して`printWeak`メソッドと`printStrong`メソッドを実装
- `Main`クラスは`PrintBanner`クラスがどうやって実現されているかを知らない
    - →`Main`クラスを全く変更せずに, `PrintBanner`クラスの実装を変更できる
- `Main`クラスにおいて
    ```java
    PrintBanner p = new PrintBanner("Hello");
    ```
    ではなく,
    ```java
    Print p = new PrintBanner("Hello");
    ```
    としているのは, 「`Print`インターフェースのメソッドを利用している」ということを強調するためである.

## インスタンスによる`Adapter`パターン(委譲を使ったもの)
> 委譲: 誰かにお任せすること(委任に同じ)
> Javaではあるメソッドの実際の処理を他のインスタンスのメソッドに任せてしまうことである

サンプルプログラムにおける電源の比喩とそれぞれのプログラムの対応関係は以下に示す通りである.(仕様も継承を使ったものと同じである)

電源の比喩とサンプルプログラムの対応関係
|| 電源の比喩 | サンプルプログラム | 備考 |
| --- | --- | --- | --- |
| 提供されているもの | 交流100V | `Banner`クラス ||
| 変換装置 | アダプター | `PrintBanner`クラス |  |
| 必要なもの | 直流12V | `Print`インターフェース ||

### 備考
- Javaでは, 2つのクラスを同時に継承することはできない(単一継承)
    - 今回の場合, `PrintBanner`クラスを, `Print`と`Banner`の両方のサブクラスとして定義することはできない
- `PrintBanner`クラスは`banner`フィールドで`Banner`クラスのインスタンスを保持する
    - このインスタンスは`PrintBanner`クラスのコンストラクタで生成する
    - `printWeak`, `printStrong`メソッドでは, その`banner`フィールドを介して`showWithParen`, `showWithAster`メソッドを呼び出す
- 自分のスーパークラスから継承したメソッドを呼ぶのではなく(→継承), 別のインスタンス(今回は`Banner`のインスタンス)のメソッド(今回は`showWithParen`メソッド)に処理を任せている(→委譲)

# 登場人物
- `Target`(対象)
    - 今必要となるメソッドを定めている役
    - 直流12Vのイメージ
    - サンプルプログラムでは`Print`インターフェース(継承の場合), `Print`クラス(委譲の場合)がこの役を務めている
- `Client`(依頼者)
    - `Target`役のメソッドを使って仕事をする役
    - 直流12Vで動く家電のイメージ
    - サンプルプログラムでは, `Main`クラスがこれに相当する
- `Adaptee`(適合される側)
    - 既に用意されているメソッドを持っている役
    - 交流100VのAC電源のイメージ
    - サンプルプログラムでは, `Banner`クラスがこれに相当する
    - `Adaptee`役のメソッドが`Target`役のメソッドに一致していたら, `Adapter`役はいらなかった(そんな事例の方が少ないけどね)
- `Adapter`(適合する側)
    - `Adaptee`役のメソッドを使って`Target`役を満たすことを目的とした役
    - 交流100Vを直流12Vに変換するアダプターのイメージ
    - サンプルプログラムでは, `PrintBanner`クラスがこれに該当する
    - クラスによる`Adapter`パターンの場合(継承の場合), `Adapter`役は「継承」を使って`Adaptee`役を利用する
    - インスタンスによる`Adapter`パターンの場合(委譲の場合), `Adapter`役は「委譲」を使って`Adaptee`役を利用する

# Adapterパターンを使う意義
- `Adapter`パターンは既存のクラスに一皮かぶせて必要となるクラスを作る(既に存在するクラスを部品として再利用する)ため, 以下のようなメリットが存在する.
    - 必要とするメソッド群を素早く作ることが可能となる.
    - もしバグが発生しても, 既存のクラス(`Adaptee`役)にはバグがないことがわかっているため, `Adapter`役を重点的に調べればよいことになり, プログラムのチェックがとても楽になる
- 新しいインターフェース(API)に適合させようとする際に, 既存のクラスには全く手を加えずに, 目的のインターフェース(API)に合わせようとするパターンである
    - 既存クラスの仕様さえわかっていれば, 新しいクラスを作成することも可能
    - 既存のクラスのソースは必要ない, 既存のクラスを修正してまたテストにかける, という手間を省くことができる
- ソフトウェアのバージョンアップを行う際に, 古い版と新しい版を共存させて, 尚且つメンテナンスを楽に行うために`Adapter`パターンが役になつことがある.
    - 例えば, 新しい版のみをメンテナンスする際に, 新しい版を`Adaptee`役, 古い版を`Target`役として, 新しい版のクラスを使って古い版のメソッドを実装する`Adapter`役のクラスを作成する, という感じで進めることができる.
- ただし, `Adaptee`役と`Target`役の機能があまりにもかけ離れている場合には, `Adapter`パターンは使えない
    - 交流100Vの電源から水道の水を出せないよね, というイメージ

# 関連しているパターン
- Bridgeパターン(第9章)
- Decoratorパターン(第12章)